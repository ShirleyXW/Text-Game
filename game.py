import random
import user
import map
import subjects
import sync_users_data
import questions_bank
import itertools

MAXIMUM_LEVEL = 3
EXPERIENCE_PER_CLASS = 2

EXPERIENCE_FOR_LEVEL_UP = 10

LEVEL_UP_INTELLIGENCE_GAIN = 3

USER_INFORMATION_FILE = "user_info.json"


def get_question(game_map, character):
    """
    Get a question based on the character's current location and subject

    The function retrieves a question based on the subject of the character's current location

    :param game_map: the map of the school
    :param character: the character's information
    :precondition: game_map must be a dictionary representing the map of the school
    :precondition: character must be a dictionary containing information about the character
    :postcondition: get a randomly selected question based on the subject of the character's current location
    :return: a randomly selected question based on the subject of the character's current location

    >>> test_map = map.generate_map()
    >>> test_character = {"location": (1, 1), "user_name": "Alice"}
    >>> random_question = get_question(test_map, test_character)
    >>> random_question in (questions_bank.NATURE_SCIENCE_QUESTIONS + questions_bank.GEOGRAPHY_QUESTIONS
    ...                     + questions_bank.COMPUTER_QUESTIONS + questions_bank.BOSS_QUESTIONS)
    True
    >>> test_map = map.generate_map()
    >>> test_character = {"location": (2, 3), "user_name": "Alice"}
    >>> random_question = get_question(test_map, test_character)
    >>> random_question in (questions_bank.NATURE_SCIENCE_QUESTIONS + questions_bank.GEOGRAPHY_QUESTIONS
    ...                             + questions_bank.COMPUTER_QUESTIONS + questions_bank.BOSS_QUESTIONS)
    True
    """
    if game_map[character["location"]].get("subject") == subjects.SCIENCE:
        return questions_bank.NATURE_SCIENCE_QUESTIONS[
            random.randint(0, len(questions_bank.NATURE_SCIENCE_QUESTIONS) - 1)]
    elif game_map[character["location"]].get("subject") == subjects.GEOGRAPHY:
        return questions_bank.GEOGRAPHY_QUESTIONS[random.randint(0, len(questions_bank.GEOGRAPHY_QUESTIONS) - 1)]
    elif game_map[character["location"]].get("subject") == subjects.COMPUTER_SCIENCE:
        return questions_bank.COMPUTER_QUESTIONS[random.randint(0, len(questions_bank.COMPUTER_QUESTIONS) - 1)]
    else:
        return questions_bank.BOSS_QUESTIONS[0]


def format_question(question):
    """
    Format a multiple-choice question

    The function formats a multiple-choice question by shuffling the answer choices and
    returning a dictionary of lettered choices along with the correct answer letter

    :param question: a dictionary containing information about the question
    :precondition: question must be a dictionary containing information about the question
    :postcondition: format a multiple-choice question
    :return: a tuple containing a dictionary of lettered choices and the correct answer letter

    >>> test_question = { "question": "What is the capital of France?", "correct_answer": "Paris",
    ... "incorrect_answers": ["London", "Berlin", "Madrid"]}
    >>> formatted_question = format_question(test_question)
    >>> len(formatted_question[0])
    4
    >>> formatted_question[0].get(formatted_question[1].upper())
    'Paris'
    >>> test_question = {
    ...    "question": "Which of the following Arab countries does NOT have a flag containing only Pan-Arab colours?",
    ...    "correct_answer": "Qatar",
    ...    "incorrect_answers": ["Kuwait", "United Arab Emirates", "Jordan"]
    ...    }

    >>> formatted_question = format_question(test_question)
    >>> len(formatted_question[0])
    4
    >>> formatted_question[0].get(formatted_question[1].upper())
    'Qatar'
    """
    letter = itertools.count(65)
    letters = []
    for element in range(65, 69):
        letters.append(chr(next(letter)))
    all_answers = [answer for answer in question["incorrect_answers"]]
    insert_index = random.randint(0, 3)
    correct_answer_letter = chr(97 + insert_index)
    all_answers.insert(insert_index, question["correct_answer"])
    multi_choice = dict(zip(letters, all_answers))
    return multi_choice, correct_answer_letter


def print_question(question_instruction, formatted_question):
    """
    Print a formatted multiple-choice question

    :param question_instruction: the instruction or prompt for the question
    :param formatted_question: a tuple containing a dictionary of lettered choices and the correct answer letter
    :precondition: formatted_question must be generated by the format_question function
    :postcondition: prints the question instruction and formatted choices
    :return: None

    >>> print_question("Select the correct capital", ({'A': 'London', 'B': 'Berlin', 'C': 'Madrid', 'D': 'Paris'}, 'd'))
    Select the correct capital
     A : London
     B : Berlin
     C : Madrid
     D : Paris
     >>> print_question("Which of the following Arab countries does NOT have a flag containing only Pan-Arab colours?",
     ... ({'A': 'Kuwait', 'B': 'Qatar', 'C': 'United Arab Emirates', 'D': 'Jordan'}, 'b'))
     Which of the following Arab countries does NOT have a flag containing only Pan-Arab colours?
      A : Kuwait
      B : Qatar
      C : United Arab Emirates
      D : Jordan
    """
    print(question_instruction)
    for choice, answer in formatted_question[0].items():
        print(" {} : {}".format(choice, answer))


def process_automatically(character, game_map):
    """
    Process classroom automatically

    :param character: a dictionary containing character's information
    :param game_map: a dictionary containing game map's information
    :precondition: character must be a valid dictionary containing information about the character
    :precondition: game_map must be a valid dictionary representing the map of the school
    :postconditions: process classroom and gain experience for character
    :return: None

    >>> test_character = {"in_question": True, "user_name": "Shirley", "location": (2, 3), "experience": 0, "level": 1}
    >>> test_map = map.generate_map()
    >>> process_automatically(test_character, test_map)
    This time your mastery of the subject captivated the class, and you effectively delivered this lesson! Keep trying Shirley
    Experience +2
    >>> test_character = {"in_question": True, "user_name": "Shirley", "location": (3, 3), "experience": 3, "level": 1}
    >>> test_map = map.generate_map()
    >>> process_automatically(test_character, test_map)
    This time your mastery of the subject captivated the class, and you effectively delivered this lesson! Keep trying Shirley
    Experience +2
    """
    character["in_question"] = False
    print("This time your mastery of the subject captivated the class, "
          "and you effectively delivered this lesson! Keep trying {}".format(character["user_name"]))
    gain_experience(character)
    game_map[character["location"]]["completed"] = True


def start_class(game_map, character):
    """
    Start a class in the current location

    :param game_map: a dictionary containing game map's information
    :param character: a dictionary containing character's information
    :precondition: game_map must be a valid dictionary representing the map of the school
    :precondition: character must be a valid dictionary containing information about the character
    :postconditions:
        - If the current location is a boss room, a tuple with question instruction and formatted question is returned
        - If the current location is not a classroom, a message is printed, and None is returned
        - If the class in the current location has already been completed, a message is printed, and `None` is returned
        - If the class can be proceeded automatically based on the character's subject mastery,
          a message printed, experience gained, and the class marked as completed
        - If the class requires a question, a message printed, and a tuple with question instruction and formatted
          question is returned
    :return: A tuple containing question instruction and formatted question if in a boss room or classroom,
             otherwise, prints messages and returns None

    >>> test_map = map.generate_map()
    >>> test_character = {"location": (0, 0), "user_name": "Alice", "in_question": False}
    >>> start_class(test_map, test_character)
    Alice, you can't start class here

    >>> test_map = map.generate_map()
    >>> test_character = {"location": (1, 1), "user_name": "Alice", "level": 4, "intelligence": 100,"experience": 0}
    >>> start_class(test_map, test_character)
    This time your mastery of the subject captivated the class, and you effectively delivered this lesson! Keep trying Alice
    Experience +2
    """
    character_location = character["location"]
    if game_map[character_location]["type"] == map.ROOM_TYPE_BOSS_ROOM:
        question = get_question(game_map, character)
        question_instruction = question["question"]
        formatted_question = format_question(question)
        character["in_question"] = True
        print_question(question_instruction, formatted_question)
        return question_instruction, formatted_question
    if game_map[character_location]["type"] != map.ROOM_TYPE_CLASS_ROOM:
        print("{}, you can't start class here".format(character["user_name"]))
        return
    if game_map[character_location]["completed"]:
        print("No class going on here.")
        return
    if is_class_proceeded_automatically(character, game_map[character_location]["subject_grade"]):
        process_automatically(character, game_map)
        return None
    else:
        print("Regrettably, your understanding of the subject falls short for teaching this class; "
              "you'll have to take an informed guess on following particular question.\n"
              "I believe you, {}. Give a try.".format(character["user_name"]))
        character["in_question"] = True
        question = get_question(game_map, character)
        question_instruction = question["question"]
        formatted_question = format_question(question)
        print_question(question_instruction, formatted_question)
        return question_instruction, formatted_question


def is_class_proceeded_automatically(character, subject_grade):
    """
    Check if the class can be proceeded automatically based on the character's subject mastery

    The higher the "intelligence" is, the higher the possibility to succeed in the class

    :param character: a dictionary containing character's information
    :param subject_grade: an integer of the grade of the subject for the class
    :precondition: character must be a dictionary containing information about the character
    :precondition: subject_grade must be a valid integer representing the grade of the subject for the class
    :postconditions: check if the gamer's intelligence greater than subject grade
    :return: True if the class can be proceeded automatically, False otherwise

    >>> is_class_proceeded_automatically({"intelligence": 100, "user_name": "Alice"}, 2)
    True
    >>> is_class_proceeded_automatically({"intelligence": 0, "user_name": "Alice"}, 2)
    False
    """
    # the higher "intelligence" is, the higher possibility succeed the class
    return random.randint(1, subject_grade * 5) <= character["intelligence"]


def is_alive(character):
    """
    Check if a character is alive based on their health

    :param character: a dictionary containing information about the character
    :precondition: character dictionary must contain a valid "health" value
    :postcondition: check if the gamer is alive or not
    :return: True if character["health"] > 0, otherwise return False

    >>> is_alive({"health": 10, "user_name": "Bob"})
    True
    >>> is_alive({"health": 0, "user_name": "Charlie"})
    False
    """
    return character["health"] > 0


def get_target_location(character, user_action):
    """
    Get the target location based on the user's action

    :param character: a dictionary containing information about the character
    :param user_action: A string representing the user's action ("n" for north, "s" for south,
                        "e" for east, "w" for west)
    :precondition: character dictionary must contain a valid "location" value, and
    :precondition: user_action must be one of the valid directions ("n", "s", "e", "w")
    :postcondition: get the target location
    :return: a tuple (row, column) representing the target location
    :raises ValueError: if user_action is invalid value

    >>> get_target_location({"user_name": "Alice", "location": (2, 2)}, "n")
    (1, 2)

    >>> get_target_location({"user_name": "Bob", "location": (3, 3)}, "e")
    (3, 4)
    """
    if user_action == "n":
        return character["location"][0] - 1, character["location"][1]
    elif user_action == "s":
        return character["location"][0] + 1, character["location"][1]
    elif user_action == "e":
        return character["location"][0], character["location"][1] + 1
    elif user_action == "w":
        return character["location"][0], character["location"][1] - 1
    else:
        raise Exception("Invalid action")


def read_book_and_increase_intelligence(character):
    """
    Read a book and increase the character's intelligence

    If the character hasn't received a bonus intelligence gain before, this function simulates the
    experience of reading a book, providing a message and increasing the character's intelligence.
    If the character has already received a bonus, it prints a message indicating that the magic is gone.

    :param character: a dictionary containing information about the character
    :precondition: character dictionary must contain valid "intelligence" and "bonus_intelligence_gain" keys
    :postcondition: increase the character's intelligence if it's the first time reading a book
    :postcondition: print a message indicating the result of reading the book
    :return: None

    >>> read_book_and_increase_intelligence({"user_name": "Alice", "intelligence": 0, "bonus_intelligence_gain": False})
    <BLANKLINE>
      Education is not merely the imparting of knowledge, but the illumination of minds.
      It's a bridge, constructed with bricks of mutual enlightenment, where the essence is
      not just information but the ignition of curiosity and the cultivation of the power
      of wisdom. The true essence of teaching lies in guiding students to discover their
      own potential, enabling them to traverse unknown realms like explorers. Education is
      not just about imparting facts; it's about igniting the flame of learning within,
      allowing students to thrive and grow amidst the sparks of contemplation.
    <BLANKLINE>
      The book says.
    <BLANKLINE>
      How do you like it, Alice?
    Your intelligence +3.
    >>> read_book_and_increase_intelligence({"user_name": "Bob", "intelligence": 0, "bonus_intelligence_gain": True})
    Seems the magic is gone. The book says. But reading is a not bad thing, Bob
    """
    if not character.get("bonus_intelligence_gain"):
        print("\n  Education is not merely the imparting of knowledge, but the illumination of minds.\n"
              "  It's a bridge, constructed with bricks of mutual enlightenment, where the essence is\n"
              "  not just information but the ignition of curiosity and the cultivation of the power\n"
              "  of wisdom. The true essence of teaching lies in guiding students to discover their\n"
              "  own potential, enabling them to traverse unknown realms like explorers. Education is\n"
              "  not just about imparting facts; it's about igniting the flame of learning within,\n"
              "  allowing students to thrive and grow amidst the sparks of contemplation.\n\n"
              "  The book says.\n\n"
              "  How do you like it, {}?".format(character["user_name"]))
        character["intelligence"] += LEVEL_UP_INTELLIGENCE_GAIN
        print("Your intelligence +{}.".format(LEVEL_UP_INTELLIGENCE_GAIN))
        character["bonus_intelligence_gain"] = True
    else:
        print("Seems the magic is gone. The book says. But reading is a not bad thing, {}".
              format(character["user_name"]))


def move_character(game_map, character, user_action):
    """
    Move the character on the game map based on the user's action

    This function calculates the target location based on the user's action and updates the character's
    location accordingly. It also checks if the target location is valid and prints the current map

    :param game_map: a dictionary representing the map of the game
    :param character: a dictionary containing information about the character
    :param user_action: a string representing the user's action
                        ("n" for north, "s" for south, "e" for east, "w" for west)
    :precondition:  game_map must be a valid dictionary
    :precondition:  character dictionary must contain valid "location", "user_name", and "level" keys
    :precondition:  user_action must be a string representing a valid action ("n", "s", "e", or "w")
    :postcondition: update the character's location based on the user's action
    :postcondition: Print the current map and additional messages if the character enters a relaxation room
    :return: None

    >>> test_map = map.generate_map()
    >>> test_character = {"user_name": "Alice", "location": (0, 0), "level": 2}
    >>> move_character(test_map, test_character, "n")
    You can't go that way
    >>> test_character = {"user_name": "Bob", "location": (4, 3), "level": 2}
    >>> move_character(test_map, test_character, "e")
    Bob can't go there. Level up to 3, then give a try.
    """
    target_location = get_target_location(character, user_action)
    character_level = character["level"]
    if target_location not in game_map:
        print("You can't go that way")
        return

    if target_location == map.BOSS_LOCATION and character_level < MAXIMUM_LEVEL:
        print("{} can't go there. Level up to 3, then give a try.".format(character["user_name"]))
        return

    character["location"] = target_location
    map.print_map_and_current_location(game_map, character)

    if game_map[target_location]["type"] == map.ROOM_TYPE_RELAX:
        read_book_and_increase_intelligence(character)


def handle_user_action_for_question(game_map, character, current_question, user_action):
    """
    Handle the user's action for a question in the game

    This function checks the validity of the user's answer and provides feedback based on whether the answer is correct
    or incorrect. It updates the character's status accordingly

    :param game_map: a dictionary representing the map of the game
    :param character: a dictionary containing information about the character
    :param current_question: A tuple containing the question instruction and the formatted question choices
    :param user_action: A string representing the user's answer choice ("a", "b", "c", or "d")
    :precondition: game_map must be a valid dictionary
    :precondition: character dictionary must contain valid "user_name", "location", and "in_question" keys
    :precondition: current_question must be a valid tuple containing the question instruction and formatted choices
    :precondition: user_action must be a string representing a valid answer choice ("a", "b", "c", or "d")
    :postcondition: provide feedback to the user based on the correctness of the answer
    :postcondition: update the character's status (experience, health, etc.) accordingly
    :return: None

    >>> test_map = map.generate_map()
    >>> test_character = {"user_name": "Alice", "location": (1, 1), "in_question": True, "health": 10}
    >>> test_formatted_question = ("What is the capital of France?",
    ...                            ({'A': 'London', 'B': 'Berlin', 'C': 'Madrid', 'D': 'Paris'}, 'd'))
    >>> handle_user_action_for_question(test_map, test_character, test_formatted_question, "a")
    Incorrect! Alice, you failed to complete the class.
    Health -1.
    >>> test_character = {"user_name": "Bob", "location": (1, 1), "in_question": True, "level": 1, "experience": 0}
    >>> test_formatted_question = ("What is the capital of France?",
    ...                            ({'A': 'London', 'B': 'Berlin', 'C': 'Madrid', 'D': 'Paris'}, 'd'))
    >>> handle_user_action_for_question(test_map, test_character, test_formatted_question, "d")
    Correct! Good job, Bob. You've completed the class.
    Experience +2
    """
    if user_action not in ("a", "b", "c", "d"):
        print("{}, invalid answer. Choose again.".format(character["user_name"]))
        print_question(current_question[0], current_question[1])
        return

    if user_action == current_question[1][1]:
        if character["location"] == map.BOSS_LOCATION:
            print("Correct! You are now a SUPER teacher, {}!".format(character["user_name"]))
            exit()
        else:
            print("Correct! Good job, {}. You've completed the class.".format(character["user_name"]))
            gain_experience(character)
            game_map[character["location"]]["completed"] = True
    else:
        if character["location"] == map.BOSS_LOCATION:
            print("Incorrect! {}, you loss extra health!".format(character["user_name"]))
            loose_health(character, 3)
        else:
            print("Incorrect! {}, you failed to complete the class.".format(character["user_name"]))
            loose_health(character, 1)

    character["in_question"] = False


def loose_health(character, minus_health):
    """
    Reduce the character's health by a specified amount

    This function decreases the character's health by the given amount and prints a message indicating the health loss

    :param character: a dictionary containing information about the character. It must have a "health" key
    :param minus_health: an integer representing the amount of health to be subtracted
    :precondition: character dictionary must contain a valid "health" key
    :precondition: minus_health must be a non-negative integer
    :postcondition: eeduce the character's health by the specified amount and prints a health loss message
    :return: None

    >>> loose_health({"user_name": "Alice", "location": (1, 1), "in_question": True, "health": 10}, 3)
    Health -3.
    >>> loose_health({"user_name": "Bob", "location": (1, 4), "in_question": True, "health": 9}, 3)
    Health -3.
    """
    print("Health -{}.".format(minus_health))
    character["health"] -= minus_health


def get_character_info(character):
    """
    Get a formatted string containing information about the character

    This function returns a formatted string with details about the character's health, level, intelligence, etc.

    :param character: a dictionary containing information about the character
    :precondition:  character dictionary must contain valid keys as "user_name",
                    "health", "max_health", "level", "intelligence", "experience"
    :postcondition: format a formatted string with character information
    :return: a formatted string with character information

    >>> test_character = {
    ...     "user_name": "Alice",
    ...     "health": 1,
    ...     "max_health": 5,
    ...     "level": 2,
    ...     "intelligence": 1,
    ...     "experience": 0 }
    >>> get_character_info(test_character)
    '\\nCurrent character Alice info:\\n  Health        1/5\\n  Level         2\\n  Intelligence  1\\n  Experience    0/10\\n'
    >>> test_character = {
    ...     "user_name": "Bob",
    ...     "health": 2,
    ...     "max_health": 5,
    ...     "level": 3,
    ...     "intelligence": 2,
    ...     "experience": 0 }
    >>> get_character_info(test_character)
    '\\nCurrent character Bob info:\\n  Health        2/5\\n  Level         3\\n  Intelligence  2\\n  Experience    0/10\\n'
    """
    return ("\nCurrent character {} info:\n"
            "  Health        {}/{}\n"
            "  Level         {}\n"
            "  Intelligence  {}\n"
            "  Experience    {}/{}\n"
            ).format(character["user_name"], character["health"], character["max_health"],
                     character["level"],
                     character["intelligence"],
                     character["experience"], EXPERIENCE_FOR_LEVEL_UP)


def check_level_up(character):
    """
    Check if the character has leveled up based on their experience

    This function checks if the character has accumulated enough experience to level up
    If so, it updates the character's level, resets the experience, and increases intelligence

    :param character: a dictionary containing information about the character
    :precondition: character dictionary must contain valid keys : "level", "experience", "intelligence"
    :postcondition: update the character's level, experience, and intelligence if a level up is achieved
    :return: True if the character leveled up, False otherwise

    >>> test_character = {
    ...     "user_name": "Alice",
    ...     "health": 1,
    ...     "max_health": 5,
    ...     "level": 2,
    ...     "intelligence": 1,
    ...     "experience": 0
    ... }
    >>> check_level_up(test_character)
    False
    >>> test_character = {
    ...     "user_name": "Alice",
    ...     "health": 1,
    ...     "max_health": 5,
    ...     "level": 2,
    ...     "intelligence": 1,
    ...     "experience": 11
    ... }
    >>> check_level_up(test_character)
    You leveled up! Your intelligence +3.
    <BLANKLINE>
    Current character Alice info:
      Health        1/5
      Level         3
      Intelligence  4
      Experience    1/10
    <BLANKLINE>
    True
    """
    if character["level"] >= MAXIMUM_LEVEL or character["experience"] < EXPERIENCE_FOR_LEVEL_UP:
        return False

    character["level"] += character["experience"] // EXPERIENCE_FOR_LEVEL_UP
    character["experience"] = character["experience"] % EXPERIENCE_FOR_LEVEL_UP
    character["intelligence"] += LEVEL_UP_INTELLIGENCE_GAIN

    print("You leveled up! Your intelligence +{}.".format(LEVEL_UP_INTELLIGENCE_GAIN))
    print(get_character_info(character))
    return True


def gain_experience(character):
    """
    Increase the character's experience based on the experience gained per class

    This function increases the character's experience by the defined amount per class
    and checks if the character has leveled up

    :param character: dictionary containing information about the character.
    :precondition: character dictionary must contain a valid key "experience"
    :postcondition: increase the character's experience and checks for a level up
    :return: None

    >>> test_character = {
    ...     "user_name": "Alice",
    ...     "health": 1,
    ...     "max_health": 5,
    ...     "level": 2,
    ...     "intelligence": 1,
    ...     "experience": 0
    ... }
    >>> gain_experience(test_character)
    Experience +2
    >>> test_character = {
    ...     "user_name": "Bob",
    ...     "health": 1,
    ...     "max_health": 5,
    ...     "level": 2,
    ...     "intelligence": 1,
    ...     "experience": 3
    ... }
    >>> gain_experience(test_character)
    Experience +2
    """
    character["experience"] += EXPERIENCE_PER_CLASS
    print("Experience +{}".format(EXPERIENCE_PER_CLASS))
    check_level_up(character)


def game():
    """
    Main function to run the game loop.

    This function initializes the character, generates the game map, and runs the game loop.
    The loop continues until the player's health is zero, the player types 'q', or the boss room is completed.

    :precondition: Assumes the existence of the user module with a 'load_or_create_character' function
    :precondition: Assumes the existence of the map module with 'generate_map' and 'print_map_and_current_location'
    :precondition: Assumes the existence of the sync_users_data module with a 'sync_user_info_to_file' function
    :precondition: Assumes the existence of the 'is_alive', 'handle_user_action_for_question', 'move_character',
                      'start_class', 'get_character_info', 'check_level_up', 'gain_experience' functions, and constants
    :postcondition: The game loop runs, and the game progresses based on user input.
    :postcondition: The loop ends when the player's health is zero, the player types 'q', or the boss room is completed
    :return: None

    The function requires user input and supports following cases:

    # Case 1: Character movement
    The character moves to a direction ('n/s/e/w')
    The move_character function is called with 'n', and the character is updated accordingly if it's a valid move.

    # Case 2: Starting a class
    The character starts a class ('x') in a classroom
    If the class is not completed, the class will be started and may be automatically proceeded based on character's
    intelligence. If class couldn't proceed automatically, a question will be generated, and the character is prompted
    to answer it.

    # Case 3: Answering a question
    The user input answer to a question ('a', 'b', 'c', or 'd').
    If the answer is correct, the character gains experience, and the class may be completed.
    If the answer is incorrect, the character loses health, and the class may not be completed.

    # Case 4: Checking character info
    The character checks their information ('i').
    The get_character_info function is called, and the character's details are printed.

    # Case 5: Viewing the map
    The character views the map ('m').
    The map.print_map function is called, and the map is printed.

    # Case 6: Exiting the game
    The character decides to exit the game ('q').
    The game ends, and the user's information will be synchronized to a file.
    """
    character = user.load_or_create_character()
    game_map = map.generate_map()
    map.print_map_and_current_location(game_map, character)
    current_question = None

    # Exit game in handle_user_action() when
    # 1. health is zero 2. user types 'q' 3. Boss room is completed
    while True:
        if not is_alive(character):
            print("Sorry {}, your journey is over. Try next time.".format(character["user_name"]))
            sync_users_data.sync_user_info_to_file(character)
            return

        user_action = input().lower()
        if user_action == "":
            continue

        # If character's status is in the class ,then check answer
        if character["in_question"] is True:
            handle_user_action_for_question(game_map, character, current_question, user_action)
            sync_users_data.sync_user_info_to_file(character)
            continue

        if user_action in ['n', 's', 'w', 'e']:
            move_character(game_map, character, user_action)
        elif user_action == 'x':
            # Start the game
            current_question = start_class(game_map, character)
        elif user_action == 'i':
            # Print the character information
            print(get_character_info(character))

        elif user_action == 'm':
            # Print the map and current location
            map.print_map(game_map, character)

        elif user_action == 'q':
            # Exit the game
            print("Bye! {}".format(character["user_name"]))
            sync_users_data.sync_user_info_to_file(character)
            return
        else:
            print("Invalid option, {}.".format(character["user_name"]))

        sync_users_data.sync_user_info_to_file(character)


def main():
    game()


if __name__ == "__main__":
    main()
